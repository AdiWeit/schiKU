<meta charset="utf-8">
<script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.4.5/angular.min.js"></script>
<select id="testTypeSelector">
  <option value="Kreis Unna">Kreis Unna</option>
  <option value="newTestType">+ Test Typ</option>
</select>
<button type="button" onclick="copyCode();" name="button">Code in die Zwischenablage kopieren</button>
<button type="button" style="display: none" id="syncWithOfficialDataButton" onclick="syncWithOfficialData(true); style.diplay = 'none';" title="bleibt gespeichert, aber wenn sich beim Offiziellen was ändert, wird das nich automatisch synchronisiert." name="button">einmalig mit offiziellen Daten überschreiben</button>
<input id="syncDataCheckbox" onchange="localStorage.setItem('syncWithOfficials', checked); syncWithOfficialData(true); refreshWords();" type="checkbox"> immer mit offiziellen Daten überschreiben
<input type="text" id="message" style="display: none">
<br>
<select id="testSelector" onchange="neededTest = words[testTypeSelector.value][value]; console.log(value)">
  <option value="Test 1">Test 1</option>
  <option value="Test 2">Test 2</option>
  <option value="Test 3">Test 3</option>
  <option value="Test 4">Test 4</option>
  <option value="Test 5">Test 5</option>
  <option value="Test 6">Test 6</option>
  <option value="newTest">+ Test</option>
</select>
<button type="button" onclick="editTest();" name="button">edit</button>
<br>
<div id="tests">
  <button type="button" id="addPupil" onclick="addPupil();" name="button">Schüler hinzufügen</button>
</div>
<div id="editor" style="display: none">
  <input type="text" id="nameType" placeholder="Name Testart">
  <input type="text" id="nameTest" placeholder="Name expliziter Test">
<div style="position: absolute; right: 0;" id="categories">
  <h1>settings</h1>
  <h2>Rubrik</h2>
<div id="rubrik">
  <br>
</div>
<button type="button" onclick="removeType('Rubrik');" name="button">X</button>
<button type="button" onclick="addTextbox(prompt('wie soll die Rubrik heißen?'), 'Rubrik', 'rubrik')" name="button">+ Rubrik</button>
  <h2>ein Graphemtreffer (für gesamte Testart)</h2>
  <div id="wortlaut">
    <br>
  </div>
  <button type="button", id="removeWord" onclick="removeType('Wortlaut');" name="button">X</button>
  <button type="button" onclick="addTextbox('', 'Wortlaut', 'wortlaut')" name="button">+ Wortlaut</button>
</div>
<h2>Wörter</h2>
<div id="word"></div>
<button type="button", id="removeWord" onclick="removeType('Wort');" name="button">X</button>
<button type="button" onclick="addTextbox('', 'Wort', 'word');" style='width: 147px; height: 20' id="addTextbox">+ Wort</button>
<br>
<button type="button" style="width: 175" onclick="closeEditor(true);" name="button">auf dem Gerät speichern und verlassen</button>
<br>
<br>
<button type="button" style="width: 175" onclick="closeEditor();" name="button">abbrechen</button>
</div>
<script>
  categories.style.left = 166 + 22;
  // TODO: einzele pupilsheet zähler für verschiedene Tests?
  // TODO: kategorien statt Kategorien
var officialData = {
      "Kreis Unna": {
        "Test 1": {
          words: ["La-ma", "Na-se", "Hu-pe", "Ro-se", "Fa-den", "Ho-se", "Ha-fen", "Sa-la-mi", "Fi-na-le", "Do-mi-no", "Ka-no-ne", "Pe-da-len", "Ta-pe-te", "Ku-si-ne", "Ra-ke-te"]
        },
        "Test 2": {
          Kategorien: {
            "Zwielaut/Diphthong": ["au", "ei"],
            sonstige: ["sch"]
          },
          words: ["Hau-fen", "An-teil", "O-fen", "Ein-kauf", "Du-sche", "Pi-rat", "Rei-fen", "Aus-lauf", "Schein", "Ka-min", "Rau-pe", "Um-tausch", "Ei-sen", "Ma-schi-ne", "En-de"]
        },
        "Test 3": {
          Kategorien: {
            "Zwielaut/Diphthong": ["au", "ei"],
            Vokale: ["ö"],
            Konsonanten: ["w"],
            sonstige: ["er", "el"]
          },
          words: ["Wein", "Rei-ter", "Am-pel", "Na-del", "Ei-mer", "Aus-weis", "Dö-ner", "Schön-heit", "Al-ter", "Le-der-ho-se", "Me-lo-nen-scha-le", "Nu-del-sa-lat", "Mo-den-schau", "Ki-lo-me-ter", "Mö-wen-fe-der"]
        },
        "Test 4": {
          Kategorien: {
            "Zwielaut/Diphthong": ["au", "ei"],
            Vokale: ["ö", "ü"],
            sonstige: ["er"]
          },
          words: ["Gei-ge", "Bau-er", "Eu-le", "Se-gel", "Bi-ber", "Beu-tel", "Ga-bel", "Ge-mü-se", "Scheu-nen-tor", "Ge-heim-tür", "Mö-bel-wa-gen", "Bü-gel-ei-sen", "Le-be-we-sen", "Ge-mein-heit", "O-fen-feu-er"]
        },
        "Test 5": {
          Kategorien: {},
          words: ["Ba-de-wan-ne", "Re-gen-man-tel", "Per-len-ket-te", "Ha-sen-fel-le", "Wasch-be-cken", "Ra-ben-fe-der", "Me-lo-nen-ker-ne", "Waf-fel-ei-sen", "Las-so-wer-fer", "Mö-bel-pa-cker",
            "Scher-ben-hau-fen", "Le-be-we-sen", "Kel-ler-e-cke", "Ta-fel-lap-pen", "Lam-pen-schal-ter"
          ]
        },
        "Test 6": {
          Kategorien: {},
          words: ["Hin-weis-schil-der", "Lie-fer-wa-gen", "Win-ter-wet-ter", "Schie-be-tür", "Ge-wit-ter-him-mel",
            "Wi-ckel-tisch", "Ge-heim-nis-se", "Tin-ten-kil-ler", "Lie-ge-wie-se", "Un-ter-kie-fer", "Rin-der-her-de", "Lie-bes-lie-der", "Re-gen-rin-ne", "Kin-der-wip-pe"
          ]
        },
        "Test 7": {
          Kategorien: {},
          words: ["Son-der-an-ge-bo-te", "Hun-de-fut-ter", "Sol-da-ten-ru-fe", "Kar-tof-fel-sor-te", "Bu-ckel-wa-le", "But-ter-do-se", "Eis-schol-le", "Re-gen-ton-ne", "Schul-ter-wun-de", "Nu-del-sup-pe", "Win-ter-soc-ken", "Fisch-kut-ter"]
        },
        "Test 8": {
          Kategorien: {},
          words: ["Sa-lat-schüs-sel", "Ra-ke-ten-böl-ler", "Kör-per-teil", "Re-gen-wür-mer", "Hun-de-hüt-te", "Ka-mel-hö-cker", "Dö-ner-bu-de", "Sup-pen-löf-fel", "Da-men-hü-te", "Fül-ler-tin-te", "Schü-ler-wün-sche", "Wör-ter-lis-te",
            "Rü-cken-num-mer", "Lö-wen-köp-fe"
          ]
        },
        einGraphemtreffer: ["ei"]
      }
    };
var words = officialData;
var neededTest = words['Kreis Unna']["Test 1"];
var pupils = 0;
var selectedElementId = {parent: 'pupilSheet1', element: 'pupilsWriting 1'};
var myBarChart = [];
  // öffnet Editor
function editTest() {
  while (document.getElementsByClassName("Wort").length > 0) {
    document.getElementsByClassName("Wort")[0].remove();
    document.getElementsByClassName("brWort")[0].remove();
  }
  while (document.getElementsByClassName("Rubrik").length > 0) {
    document.getElementsByClassName("Rubrik")[0].remove();
    document.getElementsByClassName("brRubrik")[0].remove();
  }
  while (document.getElementsByClassName("Wortlaut").length > 0) {
    document.getElementsByClassName("Wortlaut")[0].remove();
    document.getElementsByClassName("brWortlaut")[0].remove();
  }
  tests.style.display = "none";
  editor.style.display = "inline";
  if (testTypeSelector.value != "newTestType" && testSelector.value != "newTest") {
  for (var i = 0; i < neededTest.words.length; i++) {
    addTextbox(neededTest.words[i]/*, i*/, "Wort", "word");
  }
  for (var i = 0; words[testTypeSelector.value][testSelector.value].Kategorien && i < Object.keys(words[testTypeSelector.value][testSelector.value].Kategorien).length; i++) {
    addTextbox(Object.keys(words[testTypeSelector.value][testSelector.value].Kategorien)[i], "Rubrik");
  }
  for (var i = 0; i < words[testTypeSelector.value].einGraphemtreffer.length; i++) {
    addTextbox(words[testTypeSelector.value].einGraphemtreffer[i], "Wortlaut", "wortlaut");
  }
}
if (testTypeSelector.value != "newTestType") {
  nameType.value = testTypeSelector.value;
  if (testSelector.value != "newTest") {
    nameTest.value = testSelector.value;
  }
}
if (testTypeSelector.value == "newTestType" || selectedTest == "newTest") addTextbox('', /*0*/"Wort", "word");
}
// schließt Editor
// @param save: Änderungen lokal auf dem Gerät speichern
function closeEditor(save) {

  // if (!words[nameType.value][nameTest.value]) nameTest.value = nameTest.value;
  if (save) {
  if (!words[nameType.value]) words[nameType.value] = {};
  words[nameType.value].einGraphemtreffer = [];
  words[nameType.value][nameTest.value] = {words: [], Kategorien: {}};
  for (var i = 0; i < document.getElementsByClassName("Wort").length; i++) {
    words[nameType.value][nameTest.value].words.push(document.getElementsByClassName("Wort")[i].value);
  }
  for (var i = 0; i < document.getElementsByClassName("Wortlaut").length; i++) {
    words[nameType.value].einGraphemtreffer.push(document.getElementsByClassName("Wortlaut")[i].value);
  }
  for (var i = 0; i < document.getElementsByClassName("Rubrik").length; i++) {
    words[nameType.value][nameTest.value].Kategorien[document.getElementsByClassName("Rubrik")[i].value] = {};
  }
}
  editor.style.display = 'none';
  tests.style.display = 'inline';
  localStorage.setItem('words', JSON.stringify(words));
  var selected = {element: testSelector.value, testType: testTypeSelector.value};
  refreshWords();
  testSelector.value = selected.element;
  testTypeSelector.value = selected.testType;
}
/*
  ein neues Element für den Editor hinzufügen
  @param value: Text des Elements
         type: Art des Elements
         parent: wo das Element angehängt werden soll
*/
function addTextbox(value/*, i*/, type, parent) {
  if (type != "Rubrik") {
  addElement({class: type, value: value, title: 'Silben mit Bindestrich abtrennen.'}, 'input', parent);
  addElement({class: 'br' + type}, 'br', parent);
}
else {
  addElement({class: type, title: 'Silben mit Bindestrich abtrennen.'}, 'select', "rubrik");
  if (words[testTypeSelector.value][testSelector.value].Kategorien) var categories = Object.keys(words[testTypeSelector.value][testSelector.value].Kategorien);
  for (var i = 0; categories && i < categories.length; i++) {
    addElement({value: categories[i], innerText: categories[i]}, 'option', document.getElementsByClassName(type)[document.getElementsByClassName(type).length - 1], true);
  }
  if (!categories || !categories.includes(value)) addElement({value: value, innerText: value}, 'option', document.getElementsByClassName(type)[document.getElementsByClassName(type).length - 1], true);
  document.getElementsByClassName(type)[document.getElementsByClassName(type).length - 1].value = value;
  addElement({class: 'br' + type}, 'br', "rubrik");
}
}
  // lösche Element in Editor
function removeType(type) {
  document.getElementsByClassName(type)[document.getElementsByClassName(type).length - 1].remove();
  document.getElementsByClassName('br' + type)[document.getElementsByClassName('br' + type).length - 1].remove();
}
// aktuallisiert den Test, der aktuell genutzt wird
function refreshWords() {
  while (document.getElementById('testTypeSelector').options.length > 0) {
    document.getElementById('testTypeSelector').options[0] = undefined;
  }
  while (document.getElementById('testSelector').options.length > 0) {
    document.getElementById('testSelector').options[0] = undefined;
  }
  for (var i = 0; i < Object.keys(words).length; i++) {
    var nameTypeNow = Object.keys(words)[i];
    addElement({value: nameTypeNow, innerText: nameTypeNow}, 'option', 'testTypeSelector');
    for (var i1 = 0; i1 < Object.keys(words[nameTypeNow]).length; i1++) {
      var nameTestNow = Object.keys(words[nameTypeNow])[i1];
      if (nameTestNow != "einGraphemtreffer") {
      addElement({value: nameTestNow, innerText: nameTestNow}, 'option', 'testSelector');
    }
  }
  }
  addElement({value: 'newTestType', innerText: '+ Test Typ'}, 'option', 'testTypeSelector');
  addElement({value: 'newTest', innerText: '+ Test'}, 'option', 'testSelector');

  while (pupils > 0) {
    document.getElementById('pupilSheet' + pupils).remove();
    pupils--;
  }
  recreatePupils();
}
// kopiert den Code für die Tests, sodass ich be seriösen Quellen den Code direkt übernehmen kann
function copyCode() {
document.getElementById('message').style.display = "inline";
var copytext;
document.getElementById("message").value = replaceAll( replaceAll( replaceAll( replaceAll( replaceAll(JSON.stringify(words), '"Kategorien"', 'Kategorien'), '"words"', 'words' ),  '"words"', 'words'),  ':', ': '), ',', ', ');
copytext = document.getElementById("message")

copytext.select();

try{

successful = document.execCommand("copy")
message = successful ? "successful" : "unsuccessful"
}


catch(err){
document.getElementById("message").value = "Ein Fehler ist aufgetreten!!!"
}
document.getElementById('message').style.display = "none";
}
document.getElementById('addPupil').style.left = 300 + "px";
document.getElementById('addPupil').style.position = 'fixed'
// fügt alle Elemente für einen neuen Schüler hinzu
function addPupil() {
  pupils++;
  if (!inputs[/*'Test ' + */testTypeSelector.value]) inputs[/*'Test ' + */testTypeSelector.value] = {};
  if (!inputs[/*'Test ' + */testTypeSelector.value]['pupilSheet' + pupils]) inputs[/*'Test ' + */testTypeSelector.value]['pupilSheet' + pupils] = {};
  if (!inputs[/*'Test ' + */testTypeSelector.value]['pupilSheet' + pupils].testName) inputs[/*'Test ' + */testTypeSelector.value]['pupilSheet' + pupils].testName = testSelector.value;
  addElement({id: 'pupilSheet' + pupils, style: 'width:21cm; height:29.7cm'}, 'div');
  addElement({placeholder: 'Name Schüler', id: 'name', oninput: 'selectedElementId.element = id; selectedElementId.parent = "pupilSheet' + pupils + '"; dataChanged(id, value);'}, 'input', 'pupilSheet' + pupils);
  addElement({placeholder: 'Klasse', id: 'class' + pupils, style: 'width: 50;', oninput: 'selectedElementId.element = id; selectedElementId.parent = "pupilSheet' + pupils + '"; dataChanged(id, value);'}, 'input', 'pupilSheet' + pupils);
  addElement({}, 'br', 'pupilSheet' + pupils);
  addElement({placeholder: 'Datum', style: 'width: 226;', id: 'date' + pupils, oninput: 'selectedElementId.element = id; selectedElementId.parent = "pupilSheet' + pupils + '"; dataChanged(id, value);'}, 'input', 'pupilSheet' + pupils);
  addElement({placeholder: 'Anmerkungen', innerText: 'Die einzelnen Buchstaben der Laute, die nicht unter "sonstige" stehen, werden dort auch nicht mitgezählt. Wenn es keine extra Rubriken gibt, wird zudem "sonstige" nicht angezeigt.', style: 'position: absolute; right: 0px; height: 20px'/*50px*/, id: 'comment', oninput: 'selectedElementId.element = id; selectedElementId.parent = "pupilSheet' + pupils + '"; dataChanged(id, value);'}, 'textarea', 'pupilSheet' + pupils);
  addElement({id: 'divGraph' + pupils, style: 'position: absolute; right: 0px;'}, 'div', 'pupilSheet' + pupils);
  addElement({id: 'texturpupilSheet' + pupils}, 'canvas', 'divGraph' + pupils);
  addElement({}, 'br', 'pupilSheet' + pupils);
  for (var i = 0; i < neededTest.words.length; i++) {
    addElement({innerText: replaceAll(neededTest.words[i], '-', ''), id: 'word ' + (i + 1)}, 'a', 'pupilSheet' + pupils);
    addElement({id: 'pupilsWriting ' + (i + 1), style: '  color: white;', class: 'writingPupilSheet' + pupils, placeholder: 'Schreibung Schüler', oninput: 'markErrors(id, "pupilSheet' + pupils + '");', onchange: 'pupilsWritingFinished(id);', title: 'Die Eingabe wird automatisch "korrigiert". \nFalls die automatische Korrektur Fehler enthalten sollte, können Sie die Anzahl der Graphemtreffer korrigieren.\nWenn der Schüler das Wort komplett richtig geschrieben hat, geben Sie nur "r" für richtig ein!'}, 'input', 'pupilSheet' + pupils);
    addElement({id: 'correction ' + (i + 1), word: replaceAll(neededTest.words[i], '-', '')}, 'div', 'pupilSheet' + pupils);
    if (i != neededTest.words.length - 1) addElement({}, 'br', 'pupilSheet' + pupils);
  }
  addElement({id: 'allGraphemes' + pupils, style: 'font-size: 30'}, 'a', 'pupilSheet' + pupils);
}
// findet gesuchtes Unterelement, also Kind bzw. child
// @param childType: Art des Attributes, wessen Inhalt gesucht wird
//        idOfElement: Inhalt des gesuchten Attributes
//        elementNotId: wenn true: Das ganze Element wurde übergeben, nicht nur der Inhalt eines Attributes für es
function findChild(childType, idOfElement, idOfChild, elementNotId){
  if (!elementNotId) var element = document.getElementById(idOfElement);
  else var element = idOfElement;
  return element.querySelector('[' + childType + '="' + idOfChild + '"]');
}
// wird aufgerufen, wenn Eingabe der Schreibweise des Schülers durch Abwählen der Textbox (onchange) deutlich wird.
// falls nur ein "r" eigegeben wurde, wird das Wort als korrekt anerkannt.
// @param id: id der bearbeiteten Textbox
       // restoringData: falls true werden die Eingaben des Lehrers wiederhergestellt, weshalb nicht nach jedem Wort die Grafik aktuallisiert wird.
function pupilsWritingFinished(id, restoringData) {
  if (findChild('id', selectedElementId.parent, id) && findChild('id', selectedElementId.parent, id).value == "r") {
    findChild('id', selectedElementId.parent, id).value = findChild('id', selectedElementId.parent, "word " + id.replace("pupilsWriting ", "")).innerText;
    markErrors(id, selectedElementId.parent, true, restoringData);
  }
  if (!restoringData) {
    setTimeout(function () {
      getEveryCategory();
    }, 50);
  }
}
// synchronisation mit von mir hinzugefügten Tests
// @param sync: wenn true wird sychronisiert, sonst erscheint nur ein Button dafür
function syncWithOfficialData(sync) {
  for (var i = 0; i < Object.keys(officialData).length; i++) {
    var nameTypeNow = Object.keys(officialData)[i];
    for (var i1 = 0; i1 < Object.keys(officialData[nameTypeNow]).length; i1++) {
      var nameTestNow = Object.keys(officialData[nameTypeNow])[i1];
      if (sync) words[nameTypeNow][nameTestNow] = officialData[nameTypeNow][nameTestNow];
      else if (!angular.equals(words[nameTypeNow][nameTestNow], officialData[nameTypeNow][nameTestNow])) syncWithOfficialDataButton.style.display = 'inline';
    }
  }
  localStorage.setItem('words', JSON.stringify(words));
}
var auswertung = {allGraphemtreffer: {possible: 0, got: 0}, wrongLetters: {}, letter: {}, categories: {}, byCategories: {}, doNotCount: {}};
var inputs = {};
// eigen hinzugefügte Tests oder Test Typen, die nich vorprogrammiert sind werden hinzugefügt
if (localStorage.getItem('words') != "undefined" && localStorage.getItem('words')) {
  var wordsInport = JSON.parse(localStorage.getItem('words'));
  for (var i = 0; i < Object.keys(words).length; i++) {
    var nameTypeNow = Object.keys(words)[i];
    if (!(Object.keys(wordsInport).includes(nameTypeNow))) wordsInport[nameTypeNow] = words[nameTypeNow];
    for (var i1 = 0; i1 < Object.keys(words[nameTypeNow]).length; i1++) {
      var nameTestNow = Object.keys(words[nameTypeNow])[i1];
      if (!(Object.keys(wordsInport[nameTypeNow]))) wordsInport[nameTypeNow][nameTest] = words[nameTypeNow][nameTestNow];
    }
  }
  words = wordsInport;
  refreshWords();
}
if (localStorage.getItem('syncWithOfficials') == "undefined" || !localStorage.getItem('syncWithOfficials') || localStorage.getItem('syncWithOfficials') == "false") syncWithOfficialData();
else {
  syncWithOfficialData(true);
  syncDataCheckbox.checked = true;
}
// Anfragen, ob gespeicherter Fortschritt wiederhergestellt werden soll
if (localStorage.getItem('inputsSchiku') && localStorage.getItem('inputsSchiku') != 'undefined' && confirm('Wollen Sie zuletzt ausgefüllten Tests wiederherstellen? Wenn Sie auf abbrechen oder cancel klicken wird der Fortschritt verloren gehen.')) inputs = JSON.parse(localStorage.getItem('inputsSchiku'));
else if (!localStorage.getItem('inputsSchiku') || localStorage.getItem('inputsSchiku') == 'undefined' || confirm('Wenn Sie auf OK klicken gehen alle gespeicherten Eingaben von diesem Gerät verloren! Wollen Sie wirklich forfahren?')) localStorage.setItem('inputsSchiku', 'undefined');
else if (localStorage.getItem('inputsSchiku') || localStorage.getItem('inputsSchiku') != 'undefined') inputs = JSON.parse(localStorage.getItem('inputsSchiku'));
recreatePupils();
// aktuallisiert den Test, der aktuell genutzt wird
function refreshNeededTest() {
  for (var i = 0; i < Object.keys(inputs).length; i++) {
    if (Object.keys(inputs[Object.keys(inputs)[i]]).includes(selectedElementId.parent)) {
      selectedTest = Object.keys(inputs)[i];
      for (var i1 = 0; i1 < Object.keys(inputs[selectedTest]).length; i1++) {
        if (Object.keys(inputs[selectedTest])[i1] == selectedElementId.parent) neededTest = words[selectedTest][inputs[selectedTest][Object.keys(inputs[selectedTest])[i1]].testName];
      }
    }
  }
}
// stellt gespeicherten Fortschritt wieder her
function recreatePupils() {
  selectedElementId.parent = 'pupilSheet1';
  for (var i3 = 0; i3 < Object.keys(inputs).length; i3++) {
    var testAktuell = Object.keys(inputs)[i3];
    selectedTest = testAktuell;//.replace('Test ', '');
  for (var i = 0; i < Object.keys(inputs[testAktuell]).length; i++) {
    var sheetAktuell = Object.keys(inputs[testAktuell])[i];
    selectedElementId.parent = sheetAktuell;
    neededTest = words[selectedTest][inputs[testAktuell][sheetAktuell].testName];
    addPupil();
    var minusI = 0;
    for (var i1 = 0; i1 < Object.keys(inputs[testAktuell][ Object.keys(inputs[testAktuell])[i]]).length; i1++) {
      var idAktuell = Object.keys(inputs[testAktuell][ Object.keys(inputs[testAktuell])[i]])[i1];
      if (!(idAktuell.includes('mirror'))) {
      if (idAktuell.includes('pupilsWriting') && findChild('id', sheetAktuell, idAktuell)) {
      findChild('id', sheetAktuell, idAktuell).value = inputs[testAktuell][sheetAktuell][idAktuell];
      markErrors(idAktuell, sheetAktuell, undefined, true);
      pupilsWritingFinished(idAktuell, true);
    }
    else if (findChild('id', sheetAktuell, idAktuell)) {
      findChild('id', sheetAktuell, idAktuell).value = inputs[testAktuell][sheetAktuell][ idAktuell];
      minusI++;
    }
    else if (idAktuell == "Graphemtreffer") {
      for (var i2 = 0; i2 < Object.keys(inputs[testAktuell][Object.keys(inputs[testAktuell])[i]][idAktuell]).length; i2++) {
        var wordNow = Object.keys(inputs[testAktuell][Object.keys(inputs[testAktuell])[i]][idAktuell])[i2];
        findChild("id", findChild("word", sheetAktuell, wordNow), "graphemtrefferGot", true).value = inputs[testAktuell][Object.keys(inputs[testAktuell])[i]][idAktuell][wordNow].got;
        findChild("id", findChild("word", sheetAktuell, wordNow), "graphemtrefferPossible", true).value = inputs[testAktuell][Object.keys(inputs[testAktuell])[i]][idAktuell][wordNow].possible;
        getAllGraphemtreffer(true, wordNow, sheetAktuell);
      }
    }
    pupilsWritingFinished(idAktuell, true);
  }
  }
  for (var i2 = 0; inputs[testAktuell][sheetAktuell].mirror && i2 < Object.keys(inputs[testAktuell][sheetAktuell].mirror).length; i2++) {
    for (var i4 = 0; i4 < inputs[testAktuell][sheetAktuell].mirror[Object.keys(inputs[testAktuell][sheetAktuell].mirror)[i2]].length; i4++) {
      if (inputs[testAktuell][sheetAktuell].mirror[Object.keys(inputs[testAktuell][sheetAktuell].mirror)[i2]][i4]) {
      // findChild('word', sheetAktuell, Object.keys(inputs[testAktuell][sheetAktuell].mirror)[i2][i2]);
      findChild('class', findChild('word', sheetAktuell, Object.keys(inputs[testAktuell][sheetAktuell].mirror)[i2]), 'correctionLetter' + i4, true).style.backgroundColor = '#00BFFF';
    }
    }
  }
  pupilsWritingFinished(idAktuell, true);
  getEveryCategory();
    makeTextboxBigger();
  }
  }
}
// kontrolliert die Größe des Felder für Anmerkungen (wird je nach Bedarf größer und verkleinert Grafik)
function makeTextboxBigger() {
  findChild('id', selectedElementId.parent, 'comment').scroll(0, 1000);
  while (findChild('id', selectedElementId.parent, 'comment').scrollTop > 0) {
    findChild('id', selectedElementId.parent, 'comment').style.height = JSON.parse(findChild('id', selectedElementId.parent, 'comment').style.height.replace('px', '')) + 1 + 'px';
    document.getElementById('divGraph' + selectedElementId.parent.replace('pupilSheet', '')).style.top = JSON.parse(document.getElementById('divGraph' + selectedElementId.parent.replace('pupilSheet', '')).style.top.replace('px', '')) + 1 + 'px';
    document.getElementById('divGraph' + selectedElementId.parent.replace('pupilSheet', '')).style.height = JSON.parse(document.getElementById('divGraph' + selectedElementId.parent.replace('pupilSheet', '')).style.height.replace('px', '')) - 1 + 'px';
  }
}
// Angaben des Names, Schülers und Datums wird direkt nach Änderung gespeichert
// @param id: id der abgeänderten addTextbox
// @param value: Inhalt der Textbox
function dataChanged(id, value) {
  if (!inputs[/*'Test ' + */selectedTest]) inputs[/*'Test ' + */selectedTest] = {};
  if (!inputs[/*'Test ' + */selectedTest][selectedElementId.parent]) inputs[/*'Test ' + */selectedTest][selectedElementId.parent] = {};
  inputs[/*'Test ' + */selectedTest][selectedElementId.parent][id] = value;
  localStorage.setItem('inputsSchiku', JSON.stringify(inputs));
  if (id == "comment") {
    makeTextboxBigger();
  }
}
// fügt der Auswertung die falsch geschriebenen Buchstaben hinzu
function addWrongLetter(correct, i) {
  try {
    var currentLetter = correct[i].toLowerCase();
    for (var i1 = 0; i1 < Object.keys(letterList).length; i1++) {
      if (letterList[Object.keys(letterList)[i1]] && letterList[Object.keys(letterList)[i1]][currentLetter]) {
        letterList[Object.keys(letterList)[i1]][currentLetter] = false;
      }
    }
    graphemFehler++;
    if (currentLetter == "e" && i == correct.length - 1) currentLetter = '<' + currentLetter + '>';
    if (!auswertung.wrongLetters[selectedElementId.parent]) auswertung.wrongLetters[selectedElementId.parent] = {};
    if (!auswertung.wrongLetters[selectedElementId.parent][correct]) auswertung.wrongLetters[selectedElementId.parent][correct] = {};
    if (!auswertung.wrongLetters[selectedElementId.parent][correct][currentLetter]) auswertung.wrongLetters[selectedElementId.parent][correct][currentLetter] = 0;
    auswertung.wrongLetters[selectedElementId.parent][correct][currentLetter]++;
  } catch (e) {}
}
var graphemFehler = 0;
window.scroll(0, 10000);
var possibleGraphemtreffer;
var letterList;
var letterCounter;
var selectedTest = "Kreis Unna";
// überprüft Laute auf Richtigkeit und Anzahl
// @param correct: korrekte Schreibweise
//        i: aktueller Index (hier: Position im korrekten Wort)
function checkCategory(correct, i) {
  possibleGraphemtreffer = correct.length;
  if (i == 0) var firstLetter = correct[0];
  for (var i1 = 0; neededTest.Kategorien && i1 < Object.keys(neededTest.Kategorien).length; i1++) {
    var category = Object.keys(neededTest.Kategorien)[i1];
    for (var i2 = 0; i2 < neededTest.Kategorien[category].length; i2++) {
      var letterString = neededTest.Kategorien[category][i2];
      if (correct.toLowerCase().includes(letterString)) {
      for (var i3 = 0; words[testTypeSelector.value].einGraphemtreffer.includes(letterString) && i3 < letterString.length - 1; i3++) {
        possibleGraphemtreffer--;
      }
      if (!letterList[letterString]) letterList[letterString] = {};
      if (!letterCounter[letterString]) letterCounter[letterString] = [];
      if (letterCounter[letterString].length == letterString.length) {
        var string = Object.keys(letterList[letterString]).toString().replace(',', '');
        if (string == letterString) {
          if (!auswertung.categories[selectedElementId.parent]) auswertung.categories[selectedElementId.parent] = {};
          if (!auswertung.categories[selectedElementId.parent][correct]) auswertung.categories[selectedElementId.parent][correct] = {};
          if (!auswertung.categories[selectedElementId.parent][correct][category]) auswertung.categories[selectedElementId.parent][correct][category] = {got: 0, possible: 0};
          if (!auswertung.categories[selectedElementId.parent][correct][category][letterString]) auswertung.categories[selectedElementId.parent][correct][category][letterString] = {possible: 0, got: 0};
          auswertung.categories[selectedElementId.parent][correct][category][letterString].possible++;
          auswertung.categories[selectedElementId.parent][correct][category].possible++;
        var firstOne = false;
        var graphemFehlerBefore = graphemFehler;
        for (var i3 = 0; i3 < Object.keys(letterList[letterString]).length; i3++) {
          if (!letterList[letterString][Object.keys(letterList[letterString])[i3]] && !firstOne) {
            firstOne = true;
          }
          else if (!letterList[letterString][Object.keys(letterList[letterString])[i3]] && words[testTypeSelector.value].einGraphemtreffer.includes(letterString)) {
            graphemFehler--;
          }
        }
        if (graphemFehlerBefore == graphemFehler && !firstOne) {
          auswertung.categories[selectedElementId.parent][correct][category][letterString].got++;
          auswertung.categories[selectedElementId.parent][correct][category].got++;
        }
      }
        delete letterList[letterString][letterCounter[letterString][0]];
        letterCounter[letterString].shift();
      }
      letterList[letterString][correct[i].toLowerCase()] = true;
      letterCounter[letterString].push(correct[i].toLowerCase());
    }
  }
}
}
/*
 * ermittelt die Fehler des Schülers
 * Parameter: id - id des Textfeldes, wo die Schreibung des Schülers eingegeben wird
 *            parentId - Id des "Blattes" (div element) des Schülers
 *            doNotMark - wenn true wird die Anzeige für die Auswertung nicht erneuert, wodurch sie nicht zu sehen ist (bei korrekten Wörtern)
 *            doNotResetMirror -
 */
function markErrors(id, parentId, doNotMark, doNotResetMirror) {
  if (!auswertung.doNotCount[selectedElementId.parent]) auswertung.doNotCount[selectedElementId.parent] = [];
  selectedElementId = {parent: parentId, element: id};
  refreshNeededTest();
  inputs[/*'Test ' + */selectedTest][parentId][id] = findChild('id', selectedElementId.parent, id).value;
  localStorage.setItem('inputsSchiku', JSON.stringify(inputs));
  var correct = findChild('id', selectedElementId.parent, 'word ' + id.replace('pupilsWriting ', '')).innerText;
  var wrong = findChild('id', selectedElementId.parent, 'pupilsWriting ' + id.replace('pupilsWriting ', '')).value;
  var wrongI = 0;
  if (!doNotResetMirror && inputs[/*'Test ' + */selectedTest] && inputs[/*'Test ' + */selectedTest][selectedElementId.parent] && inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror) inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[correct] = [];
  if (auswertung.wrongLetters[selectedElementId.parent]) auswertung.wrongLetters[selectedElementId.parent][correct] = {};
  if (auswertung.categories[selectedElementId.parent]) auswertung.categories[selectedElementId.parent][correct] = {};
  var newWord = [];
  var addI = 0;
  var doubleError = 0;
  graphemFehler = 0;
  letterList = {};
  letterCounter = {};
  var wordCorrectionChild = findChild('id', selectedElementId.parent, 'correction ' + id.replace('pupilsWriting ', ''));
  for (var i = 0; findChild('id', wordCorrectionChild, 'correctionLetter', true); i++) {
    findChild('id', wordCorrectionChild, 'correctionLetter', true).remove();
  }
  try {
    findChild('id', wordCorrectionChild, 'graphemtrefferGot', true).remove();
    findChild('id', wordCorrectionChild, 'graphemtrefferPossible', true).remove();
    findChild('id', wordCorrectionChild, 'graphemtrefferSlash', true).remove();
    findChild('id', wordCorrectionChild, 'automaticGraphemTreffer' + correct, true).remove();
  } catch (e) {console.log(e);}
  for (var i = 0; i < wrong.length; i++) {
    newWord.push({letter: wrong[i], colour: "white"});
  }
  var original = {correct: correct, wrong: wrong};
  correct = correct.toLowerCase();
  wrong = wrong.toLowerCase();
  for (var i = 0; i < correct.length && wrong[wrongI]; i++) {
    checkCategory(original.correct, i);
    // check letter difference: following letter wrong
    if (correct[i] != wrong[wrongI] && (!wrong[wrongI + 1] || (wrong[wrongI + 1] && wrong[wrongI + 1] != correct[i]))) {
      if ((/*wrong[wrongI] == wrong[wrongI] || */correct[i] != wrong[wrongI]/*capitalizeFirstLetter(correct[i]) == correct[i]*/)/* && !(capitalizeFirstLetter(correct[i]) == correct[i] && correct[i] == wrong[wrongI])*/) {
        addWrongLetter(original.correct, i);
      }
      // console.log(correct[i] + " before " + wrong[wrongI]);
      // check if letter missing
      if ((!wrong[wrongI + 1] && (!wrong[wrongI] || wrong[wrongI] != correct[i + 1])) || (wrong[wrongI + 1] && wrong[wrongI + 1] == correct[i + 1])) {
        // console.log("remove " + wrong[wrongI] + " pos. " + wrongI);
        if (newWord[wrongI + addI]) newWord[wrongI + addI].colour = "#FD6441/*red*/";
        wrongI++;

        // check if doubleError: same letter 2 times in a row, on time false: understand, that it was not a replacement, but an added wrong letter
        if (wrong[wrongI - 2] == wrong[wrongI - 1]) {
          newWord.splice(wrongI + addI, 0, {letter: '_', colour: "white"});
          addI++;
          doubleError++;
        }
}
else {
  newWord.splice(wrongI + addI, 0, {letter: '_', colour: "white"});
  addI++;
  // graphemFehler++;
}
    }
    // getauscht check
    else if (correct[i + 1] == wrong[wrongI] && correct[i] == wrong[wrongI + 1] && correct[i] != correct[i + 1]) {
      graphemFehler++;
      newWord[wrongI + addI].colour = "#FD6441/*red*/";
      newWord[wrongI + 1 + addI].colour = "#FD6441/*red*/";
      i++;
      wrongI++;
    }
    // too much before end
    else if (((wrong[wrongI + 1] && wrong[wrongI + 1] == correct[i])) && correct[i] != wrong[wrongI]) {
      // console.log("remove " + wrong[wrongI] + " pos. " + wrongI);
      newWord[wrongI + addI].colour = "#FD6441/*red*/";
      doubleError++;
      i--;
      graphemFehler++;
    }
    // markiere falsche groß-Kleinschreibung
    else if (original.correct[i] != original.wrong[wrongI]) newWord[wrongI + addI].colour = "#FD6441/*red*/";
    if (correct[i] == wrong[wrongI - 1] && correct[i - 1] == wrong[wrongI] || (!(correct[i] != wrong[wrongI] && (!wrong[wrongI + 1] || wrongI > i || (wrong[wrongI + 1] && wrong[wrongI + 1] != correct[i]))) || (wrong[wrongI + 1] && wrong[wrongI + 1] == correct[i + 1]))) wrongI++;
  }
  checkCategory(original.correct, 0);
  // check end missing
  for (var i = i; newWord.length - doubleError < correct.length; i++) {
    newWord.push({letter: '_', colour: "white"});
    checkCategory(original.correct, /*newWord.length - 1*/i);
    addWrongLetter(original.correct, newWord.length - 1);
  }
  // check too much in the end
  for (var i = wrongI + addI; i < newWord.length && i >= correct.length; i++) {
    // console.log("remove " + wrong[i]);
    if (newWord[i].letter != '_') {
      newWord[i].colour = "#FD6441/*red*/";
      graphemFehler++;
    }
  }
  // console.log(newWord);
  for (var i = 0; i < newWord.length && !doNotMark && graphemFehler > 0; i++) {
    addElement({id: 'correctionLetter', class: 'correctionLetter' + i, innerText: newWord[i].letter, style: 'background-color:' + newWord[i].colour + ';', title: 'klicken, um ' + newWord[i].letter + ' als gespiegelt (blau) zu markieren, oder die Markierung wieder zu entfernen.\nBei Veränderung der Schreibweise des Schülers wird das Wort nicht mehr als gespiegelt eingetragen sein.', onclick: 'changeMirror(' + i + ', "' + id + '");'}, 'strong', /*'correction ' + id.replace('pupilsWriting ', '')*/wordCorrectionChild, true);
  }
  if (possibleGraphemtreffer - graphemFehler < 0) graphemFehler = possibleGraphemtreffer;
  if (!doNotMark && graphemFehler > 0) {
    addElement({value: possibleGraphemtreffer - graphemFehler, id: 'graphemtrefferGot', onchange: 'getEveryCategory();', oninput: 'getAllGraphemtreffer(true, "' + original.correct + '", "' + selectedElementId.parent + '");', class: 'graphemtrefferGot' + capitalizeFirstLetter(selectedElementId.parent), style: 'width: 25;'}, 'input', wordCorrectionChild, true);
    addElement({innerText: '/', id: 'graphemtrefferSlash', style: 'width: 25;'}, 'a', wordCorrectionChild, true);
    addElement({value: possibleGraphemtreffer, id: 'graphemtrefferPossible',onchange: 'getEveryCategory();', oninput: 'getAllGraphemtreffer(true, "' + original.correct + '", "' + selectedElementId.parent + '");', class: 'graphemtrefferPossible' + capitalizeFirstLetter(selectedElementId.parent), style: 'width: 25;'}, 'input', wordCorrectionChild, true);
    addElement({innerText: '⟲automatische Auswertung', id: 'automaticGraphemTreffer' + original.correct, onclick: 'resetGraphemtreffer("' + selectedElementId.element + '", "' + selectedElementId.parent + '");', class: 'automaticGraphemTreffer' + capitalizeFirstLetter(selectedElementId.parent), style: 'width: 100; display: none;'}, 'button', wordCorrectionChild, true);
    findChild('id', selectedElementId.parent, id).style.backgroundColor = "red";
  }
  else {
    addElement({style: 'display: none;', value: possibleGraphemtreffer - graphemFehler, id: 'graphemtrefferGot', class: 'graphemtrefferGot' + capitalizeFirstLetter(selectedElementId.parent)}, 'input', wordCorrectionChild, true);
    addElement({style: 'display: none;', value: possibleGraphemtreffer, id: 'graphemtrefferPossible', class: 'graphemtrefferPossible' + capitalizeFirstLetter(selectedElementId.parent)}, 'input', wordCorrectionChild, true);
    findChild('id', selectedElementId.parent, id).style.backgroundColor = "green";
  }
  if ((doNotMark || correct == wrong) && !auswertung.wrongLetters[selectedElementId.parent]) auswertung.wrongLetters[selectedElementId.parent] = {};
  if (doNotMark || correct == wrong) auswertung.wrongLetters[selectedElementId.parent][correct] = {};
  getAllGraphemtreffer();
}
// setzt Graphemtreffer auf Auswertung des Programmes zurrück
function resetGraphemtreffer(element, parent) {
  for (var i = 0; i < auswertung.doNotCount[parent].length; i++) {
    if (auswertung.doNotCount[parent][i] == findChild('id', parent, element.replace('pupilsWriting', 'word')).innerText) {
      auswertung.doNotCount[parent].splice(i, 1);
    }
  }
  delete inputs[selectedTest][parent].Graphemtreffer[findChild('id', parent, element.replace('pupilsWriting', 'word')).innerText]
  markErrors(element, parent);
  getEveryCategory();
}
// Zusammenzählen aller Graphemtreffer
function getAllGraphemtreffer(/*doNotMark, graphemFehler, correct*/changedByUser, correct, parent) {
  if (parent) {
    selectedElementId.parent = parent;
    refreshNeededTest();
    findChild('id', parent, 'automaticGraphemTreffer' + correct).style.display = 'inline';
  }
  auswertung.allGraphemtreffer.possible = 0;
  auswertung.allGraphemtreffer.got = 0;
  if (parent && !inputs[selectedTest][parent].Graphemtreffer) inputs[selectedTest][parent].Graphemtreffer = {};
  for (var i = 0; i < document.getElementsByClassName("graphemtrefferGot" + capitalizeFirstLetter(selectedElementId.parent)).length; i++) {
    if (i == JSON.parse(selectedElementId.element.replace('pupilsWriting ', '')) - 1 && changedByUser && !auswertung.doNotCount[selectedElementId.parent].includes(correct)) {
      auswertung.doNotCount[selectedElementId.parent].push(correct);
    }
    auswertung.allGraphemtreffer.possible += JSON.parse(document.getElementsByClassName("graphemtrefferPossible" + capitalizeFirstLetter(selectedElementId.parent))[i].value);
    auswertung.allGraphemtreffer.got += JSON.parse(document.getElementsByClassName("graphemtrefferGot" + capitalizeFirstLetter(selectedElementId.parent))[i].value);
    if (parent && replaceAll(neededTest.words[i], '-', '') == correct) {
      inputs[selectedTest][parent].Graphemtreffer[correct] = {got: JSON.parse(document.getElementsByClassName("graphemtrefferGot" + capitalizeFirstLetter(selectedElementId.parent))[i].value), possible: JSON.parse(document.getElementsByClassName("graphemtrefferPossible" + capitalizeFirstLetter(selectedElementId.parent))[i].value)};
    }
  }
  document.getElementById('allGraphemes' + selectedElementId.parent.toString().split('Sheet')[1]).innerText = 'gesamt ' + auswertung.allGraphemtreffer.got + '/' + auswertung.allGraphemtreffer.possible;
  localStorage.setItem('inputsSchiku', JSON.stringify(inputs));
}
// Schreibdiagnostik: welcher Buchstabe bzw. Laut wie häufig richtig?
// Datenübergabe und Befehl für Erstellung der Graphen
function getEveryCategory() {
  for (var i = 0; i < Object.keys(auswertung).length; i++) {
    if (Object.keys(auswertung)[i].includes("Silben")/* != "letter" && Object.keys(auswertung)[i] != "allGraphemtreffer" && Object.keys(auswertung)[i] != "wrongLetters"*/) {
      delete auswertung[Object.keys(auswertung)[i]];
      i--;
    }
  }
  auswertung.letter[selectedElementId.parent] = {};

  var minusList = {doNotCount: {}};
  if (!auswertung.doNotCount[selectedElementId.parent]) auswertung.doNotCount[selectedElementId.parent] = [];
  for (var i = 0; i < auswertung.doNotCount[selectedElementId.parent].length; i++) {
    for (var i1 = 0; i1 < auswertung.doNotCount[selectedElementId.parent][i].length; i1++) {
      var letter = auswertung.doNotCount[selectedElementId.parent][i][i1].toLowerCase();
      if (letter == "e" && i1 == auswertung.doNotCount[selectedElementId.parent][i].length - 1) letter = "<e>/<E>";
      if (!minusList[letter]) minusList[letter] = {};
      if (!minusList[letter][auswertung.doNotCount[selectedElementId.parent][i]]) minusList[letter][auswertung.doNotCount[selectedElementId.parent][i]] = 0;
      minusList[letter][auswertung.doNotCount[selectedElementId.parent][i]]++;
    }
  }
  var doNotCountObj = JSON.parse(JSON.stringify(minusList));
      doNotCountObj.laute = {};
  // Umschreibung in kategorien
  auswertung.byCategories = {};
  for (var i1 = 0; auswertung.categories[selectedElementId.parent] && i1 < Object.keys(auswertung.categories[selectedElementId.parent]).length; i1++) {
    var wordNow = Object.keys(auswertung.categories[selectedElementId.parent])[i1];
    for (var i2 = 0; i2 < Object.keys(auswertung.categories[selectedElementId.parent][wordNow]).length; i2++) {
      var category = Object.keys(auswertung.categories[selectedElementId.parent][wordNow])[i2];
      for (var i3 = 0; i3 < Object.keys(auswertung.categories[selectedElementId.parent][wordNow][category]).length; i3++) {
        var objKeyName = Object.keys(auswertung.categories[selectedElementId.parent][wordNow][category])[i3];
        if (!auswertung.byCategories[category]) auswertung.byCategories[category] = {possible: 0, got: 0};
        if (objKeyName != "got" && objKeyName != "possible") {
          if (!auswertung.doNotCount[selectedElementId.parent].includes(wordNow)) {
          if (!auswertung.byCategories[category][objKeyName]) auswertung.byCategories[category][objKeyName] = {possible: 0, got: 0};
        auswertung.byCategories[category][objKeyName].possible += auswertung.categories[selectedElementId.parent][wordNow][category][objKeyName].possible;
        auswertung.byCategories[category][objKeyName].got += auswertung.categories[selectedElementId.parent][wordNow][category][objKeyName].got;
        }
        else {
          if (!doNotCountObj.laute[objKeyName]) doNotCountObj.laute[objKeyName] = 0;
          doNotCountObj.laute[objKeyName]++;
        }
        for (var i4 = 0; i4 < objKeyName.length; i4++) {
          if (!minusList[objKeyName[i4]]) minusList[objKeyName[i4]] = {};
          if (!minusList[objKeyName[i4]][wordNow]) minusList[objKeyName[i4]][wordNow] = 0;
          minusList[objKeyName[i4]][wordNow] += auswertung.categories[selectedElementId.parent][wordNow][category][objKeyName].possible;

          if (auswertung.doNotCount[selectedElementId.parent].includes(wordNow)) {
          if (!minusList.doNotCount[objKeyName[i4]]) minusList.doNotCount[objKeyName[i4]] = 0;//{};
          // if (!minusList.doNotCount[objKeyName[i4]][wordNow]) minusList.doNotCount[objKeyName[i4]][wordNow] = 0;
          minusList.doNotCount[objKeyName[i4]]/*[wordNow]*/ += auswertung.categories[selectedElementId.parent][wordNow][category][objKeyName].possible;
          // minusList[objKeyName[i4]].got += auswertung.categories[wordNow][category][objKeyName].got;
        }
        }
      }
        else if (objKeyName == "possible") auswertung.byCategories[category].possible += auswertung.categories[selectedElementId.parent][wordNow][category].possible;
        else {
        auswertung.byCategories[category].got += auswertung.categories[selectedElementId.parent][wordNow][category].got;
        }
      }
    }
  }
  // zur Liste nach Kategorien und Alphabet geordnet hinzufügen
  var wrongList = [];
  var rightList = [];
  var mirrorList = [];
  var letterList = [];
  var categoryList = [];
  auswertung.byCategories = sortObjectByKey(auswertung.byCategories, true);
  for (var i = 0; i < Object.keys(auswertung.byCategories).length; i++) {
    var category = Object.keys(auswertung.byCategories)[i];
    categoryList.push(category);
    rightList.push(0/*auswertung.byCategories[category].got*/)
    wrongList.push(0/*auswertung.byCategories[category].possible - auswertung.byCategories[category].got*/);
    for (var i1 = 0; i1 < Object.keys(auswertung.byCategories[category]).length; i1++) {
      var objKeyName = Object.keys(auswertung.byCategories[category])[i1];
      if (objKeyName != "got" && objKeyName != "possible") {
        letterList.push(objKeyName);
        categoryList.push(objKeyName);
        rightList.push(auswertung.byCategories[category][objKeyName].got);
        wrongList.push(auswertung.byCategories[category][objKeyName].possible - auswertung.byCategories[category][objKeyName].got);
      }
    }
  }
  if (!Object.keys(auswertung.byCategories).includes('sonstige') && Object.keys(auswertung.byCategories).length > 0) {
    categoryList.push('sonstige');
    rightList.push(0/*auswertung.byCategories[category].got*/)
    wrongList.push(0/*auswertung.byCategories[category].possible - auswertung.byCategories[category].got*/);
  }
  for (var i = 0; i < neededTest.words.length; i++) {
    var inputValue = document.getElementsByClassName('writing' + capitalizeFirstLetter(selectedElementId.parent))[i].value.toLowerCase();

    // Auswertung Silben
    var label = neededTest.words[i].toString().split('-').length + ' Silben';
    var wordWithoutSilben = replaceAll(neededTest.words[i], '-', '');
    if (auswertung.doNotCount[selectedElementId.parent].includes(wordWithoutSilben)) {
    if (!doNotCountObj[label]) doNotCountObj[label] = 0;//{};
    // if (!doNotCountObj[label][wordWithoutSilben]) doNotCountObj[label][wordWithoutSilben] = 0;
    doNotCountObj[label]/*[wordWithoutSilben]*/++;
    // falls kein einziger auswertbar
    if (!auswertung[label]) auswertung[label] = {possible: 0, got: 0};
  }
    else {
      if (!auswertung[label]) auswertung[label] = {possible: 0, got: 0};
      auswertung[label].possible++;
      if (wordWithoutSilben.toLowerCase() == inputValue) auswertung[label].got++;
    }

    // Auswertung Buchstaben
    try {
    var wordNow = replaceAll(neededTest.words[i], '-', '');
      var wrongLetterAblage = JSON.parse(JSON.stringify(auswertung.wrongLetters[selectedElementId.parent][wordNow]));
      for (var i1 = 0; i1 < wordNow.length; i1++) {
        var letterNow = wordNow[i1].toLowerCase();
        if (i1 == wordNow.length - 1 && letterNow == "e")  {
          letterNow = "<e>";
          minusList["<e>"] = minusList["<e>/<E>"];
        }
        if (!auswertung.letter[selectedElementId.parent][letterNow]) auswertung.letter[selectedElementId.parent][letterNow] = {possible: 0, got: 0};
        if (!minusList[letterNow] || !minusList[letterNow][wordNow] || minusList[letterNow][wordNow] == 0) auswertung.letter[selectedElementId.parent][letterNow].possible++;
        if (!auswertung.wrongLetters[selectedElementId.parent][wordNow] || (!auswertung.wrongLetters[selectedElementId.parent][wordNow][letterNow])) {
          if (!(minusList[letterNow] && minusList[letterNow][wordNow] && minusList[letterNow][wordNow] > 0)) auswertung.letter[selectedElementId.parent][letterNow].got++;
      }
      if (auswertung.wrongLetters[selectedElementId.parent][wordNow] && auswertung.wrongLetters[selectedElementId.parent][wordNow][letterNow]) auswertung.wrongLetters[selectedElementId.parent][wordNow][letterNow]--;
      if (minusList[letterNow] && minusList[letterNow][wordNow] && minusList[letterNow][wordNow] > 0) minusList[letterNow][wordNow]--;
    }
    auswertung.wrongLetters[selectedElementId.parent][wordNow] = wrongLetterAblage;
   } catch (e) {
     console.log('not filled already');
   }
  }

    // console.log(auswertung);
    auswertung.letter[selectedElementId.parent] = sortObjectByKey(auswertung.letter[selectedElementId.parent]);
    // categoryList = Object.keys(auswertung.letter[selectedElementId.parent]);
    for (var i = 0; i < Object.keys(auswertung.letter[selectedElementId.parent]).length; i++) {
      var letter = Object.keys(auswertung.letter[selectedElementId.parent])[i];
      if (!(letterList.includes(letter[0]))) {
        categoryList.push(letter);
        // if (Object.keys(minusList).includes(letter[0])) {
          // auswertung.letter[selectedElementId.parent][letter].possible -= minusList[letter[0]].possible;
          // auswertung.letter[selectedElementId.parent][letter].got -= minusList[letter[0]].got;
        // }
        wrongList.push(auswertung.letter[selectedElementId.parent][letter].possible - auswertung.letter[selectedElementId.parent][letter].got);
        rightList.push(auswertung.letter[selectedElementId.parent][letter].got);
      }
    }
    for (var i = 0; i < Object.keys(auswertung).length; i++) {
      if (Object.keys(auswertung)[i].includes('Silben')) {
        categoryList.push(Object.keys(auswertung)[i]);
        wrongList.push(auswertung[Object.keys(auswertung)[i]].possible - auswertung[Object.keys(auswertung)[i]].got);
        rightList.push(auswertung[Object.keys(auswertung)[i]].got);
      }
    }
    for (var i = 0; i < categoryList.length; i++) {
      mirrorList.push(0);
    }
    for (var i2 = 0; inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror && i2 < Object.keys(inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror).length; i2++) {
      for (var i4 = 0; i4 < Object.keys(inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror)[i2].length; i4++) {
        if (inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[Object.keys(inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror)[i2]][i4]) {
          for (var i = 0; i < categoryList.length; i++) {
            if (categoryList[i][0] == Object.keys(inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror)[i2][i4].toLowerCase() && (categoryList[i].includes('/') || categoryList[i].length == 1)) {
              mirrorList[i]++;
              i = categoryList.length;
            }
          }
          if (i != categoryList.length + 1) {
            categoryList.push(Object.keys(inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror)[i2][i4].toLowerCase());
            mirrorList[i]++;
          }
        }
      }
      }
      var doNotCountList = [];
      for (var i = 0; i < categoryList.length; i++) {
        // normaler Buchstabe: 3 Zeichen
        if (Object.keys(doNotCountObj.laute).includes(categoryList[i])) {
          console.log(doNotCountObj.laute[categoryList[i]]);
          doNotCountList.push(doNotCountObj.laute[categoryList[i]]);
        }
        else if (categoryList[i] == "<e>/<E>" && Object.keys(doNotCountObj).includes('<e>/<E>')) {
          console.log(categoryList[i]);
          doNotCountList.push(0);
          for (var i1 = 0; i1 < Object.keys(doNotCountObj[categoryList[i]]).length; i1++) {
            console.log(doNotCountList[doNotCountList.length - 1] + doNotCountObj[categoryList[i]][Object.keys(doNotCountObj[categoryList[i]])]);
            doNotCountList[doNotCountList.length - 1] += doNotCountObj[categoryList[i]][Object.keys(doNotCountObj[categoryList[i]])];
          }
        }
        else if (Object.keys(doNotCountObj).includes(categoryList[i])) {
          console.log(doNotCountObj[categoryList[i]]);
          doNotCountList.push(doNotCountObj[categoryList[i]]);
        }
        else if ((categoryList[i].length != 3 || !Object.keys(doNotCountObj).includes(categoryList[i][0])) && categoryList[i] != "<e>/<E>") {
          doNotCountList.push(0);
        }
        else if (categoryList[i].length == 3) {
          doNotCountList.push(0);
          // if (minusList.doNotCount[categoryList[i][0]] && minusList.doNotCount[categoryList[i][0]] != 0) {
            /*minusList.doNotCount[categoryList[i][0]]*/if (minusList.doNotCount[categoryList[i][0]]) doNotCountList[doNotCountList.length - 1] -= minusList.doNotCount[categoryList[i][0]];
          // }
          // else {
          console.log(categoryList[i] + " - " + doNotCountList[doNotCountList.length - 1]);
          for (var i1 = 0; i1 < Object.keys(doNotCountObj[categoryList[i][0]]).length; i1++) {
            console.log(doNotCountList[doNotCountList.length - 1] + doNotCountObj[categoryList[i][0]][Object.keys(doNotCountObj[categoryList[i][0]])[i1]]);
            doNotCountList[doNotCountList.length - 1] += doNotCountObj[categoryList[i][0]][Object.keys(doNotCountObj[categoryList[i][0]])[i1]];
          }
        // }
        }
        else doNotCountList.push(0);
      }
    addChart(categoryList, {wrong: wrongList, right: rightList, doNotCount: doNotCountList, mirror: mirrorList});
}
// Buchstaben, die grafisch gesehen falsch verschriftlicht wurden werden markiert oder abgewählt
function changeMirror(index, wordId) {
  var word = replaceAll(neededTest.words[wordId.replace('pupilsWriting ', '') - 1], '-', '');
  if (!inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror) inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror = {};
  if (!inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word]) {
    inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word] = [];
  }
  if (!inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word][index]) {
    inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word][index] = findChild('class',  findChild('id', selectedElementId.parent, wordId.replace('pupilsWriting', 'correction')), 'correctionLetter' + index, true).style.backgroundColor;
    findChild('class',  findChild('id', selectedElementId.parent, wordId.replace('pupilsWriting', 'correction')), 'correctionLetter' + index, true).style.backgroundColor = '#00BFFF'/*blue*/;
  }
  else {
  findChild('class',  findChild('id', selectedElementId.parent, wordId.replace('pupilsWriting', 'correction')), 'correctionLetter' + index, true).style.backgroundColor = inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word][index];
  inputs[/*'Test ' + */selectedTest][selectedElementId.parent].mirror[word][index] = undefined;
}
localStorage.setItem('inputsSchiku', JSON.stringify(inputs));
getEveryCategory();
}
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
// Objekt nach key sorieren
function sortObjectByKey(obj, categories) {
  var keys = [],
  k, i, len;
for (k in obj) {
  if (obj.hasOwnProperty(k)) {
    keys.push(k);
  }
}
keys.sort();
len = keys.length;
var sorted = {}
for (i = 0; i < len; i++) {
  k = keys[i];
  if (!categories) sorted[k + "/" + k.toUpperCase()] = obj[k];
  else sorted[k] = obj[k];
}
return sorted;
}
/*
 * PURPOSE : generiert ein neues HTML Element
 *  PARAMS : attr - Attribute des Elements
 *           elm - Typ des Elements
 *           childOf - in welchem welches HTML Element soll das neue eingefügt werden? (wenn nicht angegeben wird es ganz außen unten eingefügt)
 */
  function addElement(attr, elm, childOf, asElement) {
      var newElement = document.createElement(/*'span'*/elm);
      if (childOf && !asElement) document.getElementById(childOf).appendChild(newElement);
      else if (childOf) childOf.appendChild(newElement);
      else tests.appendChild(newElement);
      for (var i = 0; i < Object.keys(attr).length; i++) {
        if (Object.keys(attr)[i] == 'innerText') newElement.innerText = attr[Object.keys(attr)[i]];
        else newElement.setAttribute(Object.keys(attr)[i]/*'style'*/, /*'color:' + word[i].colour*/attr[Object.keys(attr)[i]]);
      }
    }

    /*!
 * Determine if an element is in the viewport
 * (c) 2017 Chris Ferdinandi, MIT License, https://gomakethings.com
 * @param  {Node}    elem The element
 * @return {Boolean}      Returns true if element is in the viewport
 */
 document.onkeydown = function(event) {
   if (event.key == 'Tab' && document.getElementById(selectedElementId.element.toString().split(' ')[0] + ' ' + (JSON.parse(selectedElementId.element.toString().split(' ')[1]) + 1))) {
     setTimeout(function () {
       if (selectedElementId.element.includes('pupilsWriting')) findChild('id', selectedElementId.parent, selectedElementId.element.toString().split(' ')[0] + ' ' + (JSON.parse(selectedElementId.element.toString().split(' ')[1]) + 1)).select();
     }, 10);
   }
   if (event.key == "p" && event.ctrlKey) alert('Rand, damit ein Schüler pro Blatt bleibt: links 17mm, oben 17,5mm, oder\nlinks 20mm, oben > 21mm\nwenn Sie andere Maße wollen, scrollen Sie bei der Vorschau bis zur letzten Seite und probieren Sie es selber aus, sodass der Name oben auf dem Blatt steht.\nTipp: stellen Sie eine Entfernung vom rechten Rand ein, die ihnen gefällt und verändern (meist verkleinern) Sie den Abstand vom oberen Rand so lange, bis der Name oben auf der Seite auftaucht.');
}
function replaceAll(str, find, replace) {
    return str.replace(new RegExp(find, 'g'), replace);
}
// fügt einen neuen Graphem inzu bzw. aktuallisiert ihn
// @param texte: Beschriftung des Graphen auf der y-Achse (Balkendiagramm)
// @param data: Inhalte bzw. Daten für die Balken
function addChart(texte, data) {
  // to refresh size (not working otherwise)
  document.getElementById('textur' + selectedElementId.parent).remove();
  addElement({id: 'textur' + selectedElementId.parent}, 'canvas', 'divGraph' + selectedElementId.parent.replace('pupilSheet', ''));
  var data = {
    labels: texte,//["b statt d", "h weggelassen", "t statt l"],
    datasets: [{
      label: "richtige",
      backgroundColor: 'rgba(0, 255, 0, 0.7)',
      borderColor: 'rgba(0, 255, 0, 1)',
      fill: true,
      data: data.right,//[5,3,7],
      stack:'stack0'
    }, {
      label: "falsche",
      backgroundColor: 'rgba(255, 0, 0, 0.7)',
      borderColor: 'rgba(255, 0, 0, 1)',
      fill: true,
      data: data.wrong,
      stack:'stack0'
    }, {
      label: "nicht auswertbar",
      backgroundColor: 'gray',
      borderColor: 'gray',
      fill: true,
      data: data.doNotCount,
      stack:'stack0'
    }, {
      label: "spiegelverkehrt",
      backgroundColor: '#00BFFF',
      borderColor: '#00BFFF',
      fill: true,
      data: data.mirror,
      stack:'stack0'
    }
    ]
  }
  var options = {
    maintainAspectRatio: false,
    responsive: true,
    scales: {
      xAxes: [{
        stacked: true
      }],
      yAxes: [{
        stacked: true,
        ticks: {
          beginAtZero: true
        }
      }],
    },
  }
  myBarChart[selectedElementId.parent.replace('pupilSheet', '')] = new Chart(document.getElementById('textur' + selectedElementId.parent), {
    type: 'horizontalBar',
    data: data,
    options: options
});
console.log("selectedElementId: " + selectedElementId.parent);
var chartNow = myBarChart[selectedElementId.parent.replace('pupilSheet', '')];
document.getElementById('textur' + selectedElementId.parent).onclick = function(evt) {
  console.log("chart");
  selectedElementId.parent = evt.path[0].id.replace('textur', '');
  refreshNeededTest();
  var chartNow = myBarChart[selectedElementId.parent.replace('pupilSheet', '')];
  var activePoints = chartNow.getElementsAtEvent(evt);
  if (activePoints[0]) {
    var chartData = activePoints[0]['_chart'].config.data;
    var idx = activePoints[0]['_index'];
    var pupilSheet = chartNow.canvas.id.replace('textur', '');
    var label = chartData.labels[idx];
    if (label.includes("/") && label.length == 3) label = label[0];
    if (label == "<e>/<E>") label = "<e>";
    var right = chartData.datasets[0].data[idx];
    var wrong = chartData.datasets[1].data[idx];
    console.log(label + ': ' + right + '/' + (wrong + right) + ' (' + wrong + ' wrong)');
    console.log("selectedElementId: " + pupilSheet);
    var possibleLetterList = [];
    for (var i1 = 0; i1 < Object.keys(neededTest.Kategorien).length; i1++) {
      var category = Object.keys(neededTest.Kategorien)[i1];
      for (var i2 = 0; i2 < Object.keys(neededTest.Kategorien[category]).length; i2++) {
        var letter = neededTest.Kategorien[category][i2];
        if (letter.includes(label) && letter != label && letter != "got" && letter != "possible") possibleLetterList.push(letter);
      }
    }
      for (var i = 0; i < neededTest.words.length; i++) {

        findChild('id', pupilSheet, 'correction ' + (i + 1)).style.outlineStyle = "";
        if ((label.replace('>', '').replace('<', '').length == 1 && (neededTest.words[i].toLowerCase().includes(label.replace('>', '').replace('<', '').toLowerCase())) || (label.includes('Silben') && neededTest.words[i].toString().split('-').length == label.replace(' Silben', ''))) && findChild('id', pupilSheet, 'pupilsWriting ' + (i + 1)).value != "") {
          var result = undefined;
          if (label == 'e' && neededTest.words[i][neededTest.words[i].length - 1] == "e") {
            result = neededTest.words[i].split('');
            result.pop();
          }
          if (label.includes('Silben') || ((label != '<e>' && (!result || (result.join('').includes('e')))) || (label == '<e>' && neededTest.words[i][neededTest.words[i].length - 1] == "e"))) {
          // check if letter is included in other category
          var labelIncluded = false;
          var wordWithoutCategories = neededTest.words[i].toLowerCase();
          for (var i1 = 0; i1 < possibleLetterList.length; i1++) {
            wordWithoutCategories = replaceAll(wordWithoutCategories, possibleLetterList[i1], '');
          }
          if (wordWithoutCategories.includes(label) || possibleLetterList.length == 0) {
          findChild('id', pupilSheet, 'correction ' + (i + 1)).style.outlineColor = "red";
          if ((!Object.keys(auswertung.wrongLetters[pupilSheet][replaceAll(neededTest.words[i], '-', '')]).length || (!auswertung.wrongLetters[pupilSheet][replaceAll(neededTest.words[i], '-', '')][label])) && (!(label.includes('Silben')) || findChild('id', pupilSheet, 'pupilsWriting ' + (i + 1)).value == replaceAll(neededTest.words[i], '-', ''))) findChild('id', pupilSheet, 'correction ' + (i + 1)).style.outlineColor = "green";
          if (auswertung.doNotCount[selectedElementId.parent].includes(replaceAll(neededTest.words[i], '-', ''))) findChild('id', pupilSheet, 'correction ' + (i + 1)).style.outlineColor = "gray";
          findChild('id', pupilSheet, 'correction ' + (i + 1)).style.outlineStyle = "outset";
          findChild('id', pupilSheet, 'correction ' + (i + 1)).style.width = graphemtrefferPossible[neededTest.words.length*(pupilSheet.replace('pupilSheet', '') - 1) + i].getBoundingClientRect().right + 3;
          if (findChild('id', pupilSheet, 'pupilsWriting ' + (i + 1)).value == replaceAll(neededTest.words[i], '-', '')) findChild('id', pupilSheet, 'correction ' + (i + 1)).style.width = 7*replaceAll(neededTest.words[i], '-', '').length;
        }
        }
      }
      if (label.replace('>', '').replace('<', '').length > 1 && !(label.includes("Silben"))) {
        var wordNow = replaceAll(neededTest.words[i], '-', '');
        findChild('word', pupilSheet, wordNow).style.outlineStyle = "";
        for (var i1 = 0; i1 < Object.keys(auswertung.categories[selectedElementId.parent][wordNow]).length; i1++) {
          var category = Object.keys(auswertung.categories[selectedElementId.parent][wordNow])[i1];
          for (var i2 = 0; i2 < Object.keys(auswertung.categories[selectedElementId.parent][wordNow][category]).length; i2++) {
            var letter = Object.keys(auswertung.categories[selectedElementId.parent][wordNow][category])[i2];
            if (auswertung.categories[selectedElementId.parent][wordNow][category][letter].possible && letter == label) {
              findChild('word', pupilSheet, wordNow).style.outlineColor = "red";
              if (auswertung.categories[selectedElementId.parent][wordNow][category][letter].possible == auswertung.categories[selectedElementId.parent][wordNow][category][letter].got) findChild('word', pupilSheet, wordNow).style.outlineColor = "green";
              if (auswertung.doNotCount[selectedElementId.parent].includes(wordNow)) findChild('word', pupilSheet, wordNow).style.outlineColor = "gray";
              findChild('word', pupilSheet, wordNow).style.outlineStyle = "outset";
              findChild('word', pupilSheet, wordNow).style.width = graphemtrefferPossible[neededTest.words.length*(pupilSheet.replace('pupilSheet', '') - 1) + i].getBoundingClientRect().right + 3;
              if (Object.keys(auswertung.wrongLetters[selectedElementId.parent][wordNow]).length == 0 && auswertung.categories[selectedElementId.parent][wordNow][category][letter].possible == auswertung.categories[selectedElementId.parent][wordNow][category][letter].got) findChild('word', pupilSheet, wordNow).style.width = 7*replaceAll(neededTest.words[i], '-', '').length;
            }
          }
        }
      }
    }
  }
};
var mostLeft = 0;
for (var i = 0; i < document.getElementsByClassName('writing' + selectedElementId.parent).length; i++) {
  if (document.getElementsByClassName('writing' + selectedElementId.parent)[i].getBoundingClientRect().right > mostLeft) mostLeft = document.getElementsByClassName('writing' + selectedElementId.parent)[i].getBoundingClientRect().right;
}
chartNow.canvas.parentNode.style.right = -20
chartNow.canvas.parentNode.style.width = window.innerWidth - mostLeft - 10 - (window.innerWidth - document.getElementById(selectedElementId.parent).getBoundingClientRect().right);
chartNow.canvas.parentNode.style.height = 1;
chartNow.canvas.parentNode.style.top = document.getElementById(selectedElementId.parent).getBoundingClientRect().top + 40 + scrollY;
for (var graphBottom = document.getElementById('divGraph' + selectedElementId.parent.replace('pupilSheet', '')).getBoundingClientRect().bottom; document.getElementById(selectedElementId.parent).getBoundingClientRect().bottom > graphBottom; graphBottom++) {
  chartNow.canvas.parentNode.style.height = JSON.parse(chartNow.canvas.parentNode.style.height.replace('px', '')) + 1 + 'px';
}
findChild('id', selectedElementId.parent, 'comment').style.width = window.innerWidth - mostLeft - 65- (window.innerWidth - document.getElementById(selectedElementId.parent).getBoundingClientRect().right);
findChild('id', selectedElementId.parent, 'comment').style.height = 10;
makeTextboxBigger();

console.log(chartNow.canvas.parentNode.style.height);
}
</script>
